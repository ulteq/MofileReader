<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MofileReader: [XRegExp](http://xregexp.com/)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MofileReader
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_node_modules_xregexp__r_e_a_d_m_e.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">[XRegExp](<a href="http://xregexp.com/">http://xregexp.com/</a>) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>XRegExp provides augmented, extensible, cross-browser JavaScript regular expressions. You get new syntax and flags beyond what browsers support natively, along with a collection of utils to make your client-side grepping and parsing easier. XRegExp also frees you from worrying about pesky inconsistencies in cross-browser regex handling and the dubious <code>lastIndex</code> property.</p>
<p>XRegExp supports all native ES5 regular expression syntax. It's about 3.5 KB when minified and gzipped. It works with Internet Explorer 5.5+, Firefox 1.5+, Chrome, Safari 3+, and Opera 9.5+.</p>
<h2>Performance</h2>
<p>XRegExp regular expressions compile to native RegExp objects, thus there is no performance difference when using XRegExp objects with native methods. There is a small performance cost when <em>compiling</em> XRegExps. If you want, however, you can use <code>XRegExp.cache</code> to avoid ever incurring the compilation cost for a given pattern more than once. Doing so can even lead to XRegExp being faster than native regexes in synthetic tests that repeatedly compile the same regex.</p>
<h2>Usage examples</h2>
<div class="fragment"><div class="line">// Using named capture and flag x (free-spacing and line comments)</div><div class="line">var date = XRegExp(&#39;(?&lt;year&gt;  [0-9]{4}) -?  # year  \n\</div><div class="line">                    (?&lt;month&gt; [0-9]{2}) -?  # month \n\</div><div class="line">                    (?&lt;day&gt;   [0-9]{2})     # day   &#39;, &#39;x&#39;);</div><div class="line"></div><div class="line">// XRegExp.exec gives you named backreferences on the match result</div><div class="line">var match = XRegExp.exec(&#39;2012-02-22&#39;, date);</div><div class="line">match.day; // -&gt; &#39;22&#39;</div><div class="line"></div><div class="line">// It also includes optional pos and sticky arguments</div><div class="line">var pos = 3, result = [];</div><div class="line">while (match = XRegExp.exec(&#39;&lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;5&lt;6&gt;&#39;, /&lt;(\d+)&gt;/, pos, &#39;sticky&#39;)) {</div><div class="line">    result.push(match[1]);</div><div class="line">    pos = match.index + match[0].length;</div><div class="line">} // result -&gt; [&#39;2&#39;, &#39;3&#39;, &#39;4&#39;]</div><div class="line"></div><div class="line">// XRegExp.replace allows named backreferences in replacements</div><div class="line">XRegExp.replace(&#39;2012-02-22&#39;, date, &#39;${month}/${day}/${year}&#39;); // -&gt; &#39;02/22/2012&#39;</div><div class="line">XRegExp.replace(&#39;2012-02-22&#39;, date, function (match) {</div><div class="line">    return match.month + &#39;/&#39; + match.day + &#39;/&#39; + match.year;</div><div class="line">}); // -&gt; &#39;02/22/2012&#39;</div><div class="line"></div><div class="line">// In fact, all XRegExps are RegExps and work perfectly with native methods</div><div class="line">date.test(&#39;2012-02-22&#39;); // -&gt; true</div><div class="line"></div><div class="line">// The *only* caveat is that named captures must be referred to using numbered backreferences</div><div class="line">&#39;2012-02-22&#39;.replace(date, &#39;$2/$3/$1&#39;); // -&gt; &#39;02/22/2012&#39;</div><div class="line"></div><div class="line">// If you want, you can extend native methods so you don&#39;t have to worry about this</div><div class="line">// Doing so also fixes numerous browser bugs in the native methods</div><div class="line">XRegExp.install(&#39;natives&#39;);</div><div class="line">&#39;2012-02-22&#39;.replace(date, &#39;${month}/${day}/${year}&#39;); // -&gt; &#39;02/22/2012&#39;</div><div class="line">&#39;2012-02-22&#39;.replace(date, function (match) {</div><div class="line">    return match.month + &#39;/&#39; + match.day + &#39;/&#39; + match.year;</div><div class="line">}); // -&gt; &#39;02/22/2012&#39;</div><div class="line">date.exec(&#39;2012-02-22&#39;).day; // -&gt; &#39;22&#39;</div><div class="line"></div><div class="line">// Extract every other digit from a string using XRegExp.forEach</div><div class="line">XRegExp.forEach(&#39;1a2345&#39;, /\d/, function (match, i) {</div><div class="line">    if (i % 2) this.push(+match[0]);</div><div class="line">}, []); // -&gt; [2, 4]</div><div class="line"></div><div class="line">// Get numbers within &lt;b&gt; tags using XRegExp.matchChain</div><div class="line">XRegExp.matchChain(&#39;1 &lt;b&gt;2&lt;/b&gt; 3 &lt;b&gt;4 a 56&lt;/b&gt;&#39;, [</div><div class="line">    XRegExp(&#39;(?is)&lt;b&gt;.*?&lt;/b&gt;&#39;),</div><div class="line">    /\d+/</div><div class="line">]); // -&gt; [&#39;2&#39;, &#39;4&#39;, &#39;56&#39;]</div><div class="line"></div><div class="line">// You can also pass forward and return specific backreferences</div><div class="line">var html = &#39;&lt;a href=&quot;http://xregexp.com/&quot;&gt;XRegExp&lt;/a&gt;\</div><div class="line">            &lt;a href=&quot;http://www.google.com/&quot;&gt;Google&lt;/a&gt;&#39;;</div><div class="line">XRegExp.matchChain(html, [</div><div class="line">    {regex: /&lt;a href=&quot;([^&quot;]+)&quot;&gt;/i, backref: 1},</div><div class="line">    {regex: XRegExp(&#39;(?i)^https?://(?&lt;domain&gt;[^/?#]+)&#39;), backref: &#39;domain&#39;}</div><div class="line">]); // -&gt; [&#39;xregexp.com&#39;, &#39;www.google.com&#39;]</div><div class="line"></div><div class="line">// XRegExp.union safely merges strings and regexes into a single pattern</div><div class="line">XRegExp.union([&#39;a+b*c&#39;, /(dogs)\1/, /(cats)\1/], &#39;i&#39;);</div><div class="line">// -&gt; /a\+b\*c|(dogs)\1|(cats)\2/i</div></div><!-- fragment --><p>These examples should give you the flavor of what's possible, but XRegExp has more syntax, flags, utils, options, and browser fixes that aren't shown here. You can even augment XRegExp's regular expression syntax with addons (see below) or write your own. See <a href="http://xregexp.com/">xregexp.com</a> for more details.</p>
<h2>Addons</h2>
<p>In browsers, you can either load addons individually, or bundle all addons together with XRegExp by loading <code>xregexp-all.js</code>. XRegExp's <a href="http://npmjs.org/">npm</a> package uses <code>xregexp-all.js</code>, which means that the addons are always available when XRegExp is installed on the server using npm.</p>
<h3>XRegExp Unicode Base</h3>
<p>In browsers, first include the Unicode Base script:</p>
<div class="fragment"><div class="line">&lt;script src=&quot;xregexp.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script src=&quot;addons/unicode/unicode-base.js&quot;&gt;&lt;/script&gt;</div></div><!-- fragment --><p>Then you can do this:</p>
<div class="fragment"><div class="line">var unicodeWord = XRegExp(&#39;^\\p{L}+$&#39;);</div><div class="line">unicodeWord.test(&#39;Русский&#39;); // -&gt; true</div><div class="line">unicodeWord.test(&#39;日本語&#39;); // -&gt; true</div><div class="line">unicodeWord.test(&#39;العربية&#39;); // -&gt; true</div></div><!-- fragment --><p>The base script adds <code>\p{Letter}</code> and its alias <code>\p{L}</code>, but other Unicode categories, scripts, blocks, and properties require addon packages. Try these next examples after additionally including <code>unicode-scripts.js</code>:</p>
<div class="fragment"><div class="line">XRegExp(&#39;^\\p{Hiragana}+$&#39;).test(&#39;ひらがな&#39;); // -&gt; true</div><div class="line">XRegExp(&#39;^[\\p{Latin}\\p{Common}]+$&#39;).test(&#39;Über Café.&#39;); // -&gt; true</div></div><!-- fragment --><p>XRegExp uses the Unicode 6.1 Basic Multilingual Plane.</p>
<h3>XRegExp.build</h3>
<p>In browsers, first include the script:</p>
<div class="fragment"><div class="line">&lt;script src=&quot;xregexp.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script src=&quot;addons/build.js&quot;&gt;&lt;/script&gt;</div></div><!-- fragment --><p>You can then build regular expressions using named subpatterns, for readability and pattern reuse:</p>
<div class="fragment"><div class="line">var time = XRegExp.build(&#39;(?x)^ {{hours}} ({{minutes}}) $&#39;, {</div><div class="line">    hours: XRegExp.build(&#39;{{h12}} : | {{h24}}&#39;, {</div><div class="line">        h12: /1[0-2]|0?[1-9]/,</div><div class="line">        h24: /2[0-3]|[01][0-9]/</div><div class="line">    }, &#39;x&#39;),</div><div class="line">    minutes: /^[0-5][0-9]$/</div><div class="line">});</div><div class="line"></div><div class="line">time.test(&#39;10:59&#39;); // -&gt; true</div><div class="line">XRegExp.exec(&#39;10:59&#39;, time).minutes; // -&gt; &#39;59&#39;</div></div><!-- fragment --><p>Named subpatterns can be provided as strings or regex objects. A leading <code>^</code> and trailing unescaped <code>$</code> are stripped from subpatterns if both are present, which allows embedding independently useful anchored patterns. <code>{{…}}</code> tokens can be quantified as a single unit. Backreferences in the outer pattern and provided subpatterns are automatically renumbered to work correctly within the larger combined pattern. The syntax <code>({{name}})</code> works as shorthand for named capture via <code>(?&lt;name&gt;{{name}})</code>. Named subpatterns cannot be embedded within character classes.</p>
<p>See also: <em><a href="http://blog.stevenlevithan.com/archives/grammatical-patterns-xregexp-build">Creating Grammatical Regexes Using XRegExp.build</a></em>.</p>
<h3>XRegExp.matchRecursive</h3>
<p>In browsers, first include the script:</p>
<div class="fragment"><div class="line">&lt;script src=&quot;xregexp.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script src=&quot;addons/matchrecursive.js&quot;&gt;&lt;/script&gt;</div></div><!-- fragment --><p>You can then match recursive constructs using XRegExp pattern strings as left and right delimiters:</p>
<div class="fragment"><div class="line">var str = &#39;(t((e))s)t()(ing)&#39;;</div><div class="line">XRegExp.matchRecursive(str, &#39;\\(&#39;, &#39;\\)&#39;, &#39;g&#39;);</div><div class="line">// -&gt; [&#39;t((e))s&#39;, &#39;&#39;, &#39;ing&#39;]</div><div class="line"></div><div class="line">// Extended information mode with valueNames</div><div class="line">str = &#39;Here is &lt;div&gt; &lt;div&gt;an&lt;/div&gt;&lt;/div&gt; example&#39;;</div><div class="line">XRegExp.matchRecursive(str, &#39;&lt;div\\s*&gt;&#39;, &#39;&lt;/div&gt;&#39;, &#39;gi&#39;, {</div><div class="line">    valueNames: [&#39;between&#39;, &#39;left&#39;, &#39;match&#39;, &#39;right&#39;]</div><div class="line">});</div><div class="line">/* -&gt; [</div><div class="line">{name: &#39;between&#39;, value: &#39;Here is &#39;,       start: 0,  end: 8},</div><div class="line">{name: &#39;left&#39;,    value: &#39;&lt;div&gt;&#39;,          start: 8,  end: 13},</div><div class="line">{name: &#39;match&#39;,   value: &#39; &lt;div&gt;an&lt;/div&gt;&#39;, start: 13, end: 27},</div><div class="line">{name: &#39;right&#39;,   value: &#39;&lt;/div&gt;&#39;,         start: 27, end: 33},</div><div class="line">{name: &#39;between&#39;, value: &#39; example&#39;,       start: 33, end: 41}</div><div class="line">] */</div><div class="line"></div><div class="line">// Omitting unneeded parts with null valueNames, and using escapeChar</div><div class="line">str = &#39;...{1}\\{{function(x,y){return y+x;}}&#39;;</div><div class="line">XRegExp.matchRecursive(str, &#39;{&#39;, &#39;}&#39;, &#39;g&#39;, {</div><div class="line">    valueNames: [&#39;literal&#39;, null, &#39;value&#39;, null],</div><div class="line">    escapeChar: &#39;\\&#39;</div><div class="line">});</div><div class="line">/* -&gt; [</div><div class="line">{name: &#39;literal&#39;, value: &#39;...&#39;, start: 0, end: 3},</div><div class="line">{name: &#39;value&#39;,   value: &#39;1&#39;,   start: 4, end: 5},</div><div class="line">{name: &#39;literal&#39;, value: &#39;\\{&#39;, start: 6, end: 8},</div><div class="line">{name: &#39;value&#39;,   value: &#39;function(x,y){return y+x;}&#39;, start: 9, end: 35}</div><div class="line">] */</div><div class="line"></div><div class="line">// Sticky mode via flag y</div><div class="line">str = &#39;&lt;1&gt;&lt;&lt;&lt;2&gt;&gt;&gt;&lt;3&gt;4&lt;5&gt;&#39;;</div><div class="line">XRegExp.matchRecursive(str, &#39;&lt;&#39;, &#39;&gt;&#39;, &#39;gy&#39;);</div><div class="line">// -&gt; [&#39;1&#39;, &#39;&lt;&lt;2&gt;&gt;&#39;, &#39;3&#39;]</div></div><!-- fragment --><p><code>XRegExp.matchRecursive</code> throws an error if it sees an unbalanced delimiter in the target string.</p>
<h3>XRegExp Prototype Methods</h3>
<p>In browsers, first include the script:</p>
<div class="fragment"><div class="line">&lt;script src=&quot;xregexp.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script src=&quot;addons/prototypes.js&quot;&gt;&lt;/script&gt;</div></div><!-- fragment --><p>New XRegExp regexes then gain a collection of useful methods: <code>apply</code>, <code>call</code>, <code>forEach</code>, <code>globalize</code>, <code>xexec</code>, and <code>xtest</code>.</p>
<div class="fragment"><div class="line">// To demonstrate the call method, let&#39;s first create the function we&#39;ll be using...</div><div class="line">function filter(array, fn) {</div><div class="line">    var res = [];</div><div class="line">    array.forEach(function (el) {if (fn.call(null, el)) res.push(el);});</div><div class="line">    return res;</div><div class="line">}</div><div class="line">// Now we can filter arrays using functions and regexes</div><div class="line">filter([&#39;a&#39;, &#39;ba&#39;, &#39;ab&#39;, &#39;b&#39;], XRegExp(&#39;^a&#39;)); // -&gt; [&#39;a&#39;, &#39;ab&#39;]</div></div><!-- fragment --><p>Native <code>RegExp</code> objects copied by <code>XRegExp</code> are augmented with any <code>XRegExp.prototype</code> methods. The following lines therefore work equivalently:</p>
<div class="fragment"><div class="line">XRegExp(&#39;[a-z]&#39;, &#39;ig&#39;).xexec(&#39;abc&#39;);</div><div class="line">XRegExp(/[a-z]/ig).xexec(&#39;abc&#39;);</div><div class="line">XRegExp.globalize(/[a-z]/i).xexec(&#39;abc&#39;);</div></div><!-- fragment --><h2>Installation and usage</h2>
<p>In browsers:</p>
<div class="fragment"><div class="line">&lt;script src=&quot;xregexp-min.js&quot;&gt;&lt;/script&gt;</div></div><!-- fragment --><p>Or, to bundle XRegExp with all of its addons:</p>
<div class="fragment"><div class="line">&lt;script src=&quot;xregexp-all-min.js&quot;&gt;&lt;/script&gt;</div></div><!-- fragment --><p>Using <a href="http://npmjs.org/">npm</a>:</p>
<div class="fragment"><div class="line">npm install xregexp</div></div><!-- fragment --><p>In <a href="http://nodejs.org/">Node.js</a> and <a href="http://wiki.commonjs.org/wiki/Modules">CommonJS module</a> loaders:</p>
<div class="fragment"><div class="line">var XRegExp = require(&#39;xregexp&#39;).XRegExp;</div></div><!-- fragment --><h3>Running tests on the server with npm</h3>
<div class="fragment"><div class="line">npm install -g qunit  # needed to run the tests</div><div class="line">npm test  # in the xregexp root</div></div><!-- fragment --><p>If XRegExp was not installed using npm, just open <code>tests/index.html</code> in your browser.</p>
<h2>&amp;c</h2>
<p><b>Lookbehind:</b> A <a href="https://gist.github.com/2387872">collection of short functions</a> is available that makes it easy to simulate infinite-length leading lookbehind.</p>
<h2>Changelog</h2>
<ul>
<li>Releases: <a href="http://xregexp.com/history/">Version history</a>.</li>
<li>Upcoming: <a href="https://github.com/slevithan/XRegExp/issues/milestones">Milestones</a>, <a href="https://github.com/slevithan/XRegExp/wiki/Roadmap">Roadmap</a>.</li>
</ul>
<h2>About</h2>
<p>XRegExp and addons copyright 2007-2012 by <a href="http://stevenlevithan.com/">Steven Levithan</a>.</p>
<p>Tools: Unicode range generators by <a href="http://mathiasbynens.be/">Mathias Bynens</a>. Source file concatenator by <a href="http://twitter.com/walling">Bjarke Walling</a>.</p>
<p>Prior art: <code>XRegExp.build</code> inspired by <a href="http://lea.verou.me/">Lea Verou</a>'s <a href="http://lea.verou.me/2011/03/create-complex-regexps-more-easily/">RegExp.create</a>. <code>XRegExp.union</code> inspired by <a href="http://www.ruby-lang.org/">Ruby</a>. XRegExp's syntax extensions come from Perl, .NET, etc.</p>
<p>All code released under the <a href="http://mit-license.org/">MIT License</a>.</p>
<p>Fork me to show support, fix, and extend. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Nov 6 2018 21:11:58 for MofileReader by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
